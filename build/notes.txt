__ROM and CPU address layout discovery__

    001f8000 in main_z1.sfc is start
    002bf130 in main_z1.sfc is EOF
    00208000 in main_z1.sfc is start of bank 0:

    org $A08000
    incbin "../../resources/zelda1prg0.nes":($0010)-($4010)
    incbin "../../resources/zelda1prg0.nes":($1C010)-($20010)


    00600000 in main.sfc is start of bank 0 (but rom.asm says it should be 608000?)
    00608000 in main.sfc is start of bank 1
    00610000 in main.sfc is start of bank 2
    00618000 in main.sfc is start of bank 3
    00620000 in main.sfc is start of bank 4
    ...
    0063c000 in main.sfc is start of (final copy) bank 7

    007fffff in main.sfc is EOF

    ** Zelda 1 starts at 00600000 in rom
        length 4576e-976e == 3c000
    ** Metroid 1 starts at 00680004 in rom
        length == 38000
    Note that we can use asar's "print bytes" to determine ranges accurately, but NOT final offsets
    e.g., it correctly calculated the metroid rom taking 0x38000 bytes in main.sfc, but says its start offset is
    0x4effc (actual rom offset: 0x680004; not even close)




ring/tunic subroutine (no - this is something related to ganon/ganon triforce):
[0x8E, 0x02, 0x06, 0x8E, 0x72, 0x06, 0xEE, 0x4F, 0x03, 0x60]
STX $0602   ;  Duplicating the overwritten code (writing #$02)
STX $0672   ;  Copying [X (#$02)] to $0672 also (tunic palette maybe? rammap dunnos)
INC $034f   ;  Enemies killed on current screen (...)
RTS

8e 02 06 8e 72 06 ee 4f 03 60  - z1r has same [ganon-related] sub as above.  hmm.

20 e4 ff  z1r hook in exact same spot too..
The code does not seem to have anything to do with palettes or tunics or anything.
** Code runs on Ganon kill.  Makes more sense - it must be some type of ganon bugfix patch.

Create a patch from a vanilla rom change and apply it to a changed rom (different rando seed; whatever)
D:\Projects\multirando-asm\resources>flips --ignore-checksum --apply ..\build\Z-slowtext.bps ..\build\z1r.nes z1r-slowtext.nes
Done.  Works!


***  Bank_1_Code starts in SAVE RAM AT 006C90!!, not at 0x8000 where the rest of the swapped banks start
test offsets.

__Bank 1 low prg bank location example__
@Take: code starts with 20 xx xx B5(or BD) xx oo 29 3f 48
Located at 890f in cpu space
Located at 490f in the full rom (sans header)

__Bank 1 in save ram example__
TakeItem: code starts with:  a2 08 8e 02 06 c9 0e
Located at ABE0 in "bank 1 8000 offset",
which is   6bf0 in the full rom
which is   6be0 without the header
so subtract 4000 from the offsets in https://www.computerarcheology.com/NES/Zelda/Bank1.html

find this code in the mesen debugger
TakeItem: is at CPU 7370.  (1370 of sram)  
BANK1_CODE starts in rom (sans offset) at 6500.
BANK1_Code starts in sram at 0c90
So, CPU offsets into bank1 are <desired ROM location> + 0790.

sram 1484 is HandleClass2:
The ring portion at the end of this sub just stores the new palette byte
in 6804 (sram).  Then, stores #$18 (hardcode; not contingent on ring type)
in zero page $14 (TileBufSelector / ppu loading index)
and increments zero page $13 (game submode / routine index)

The motherbrain item obtain code references SRAM_ITEM_BUFFER
which unfortunately only stores the small snapshot of z1 ram that tracks items.
neither zero page nor wram at 6000 is stored in this shared sram space.
So: use the debugger and set a write breakpoint in wram at 6804, then trigger
a z1 transition to see if you can identify what code actually writes/restores
wram for z1.  Then do the same for a zero page value.
    - If this storage can be written by the motherbrain item obtain code, prefer that.
    - If not, find some other way
    - If in the unfathomable event that zero page and wram for z1 gets recreated from scratch
    on each and every game transition and values never get stored, you'll have to hack in the
    ring code somewhere during the transition / initialization (see transition_in.asm).
    There is specific manhandling of various zero page values in there, e.g.:
        stz $13     ; Clear submode

Try debug catching obtaining blue ring from shop, leaving z1, and reentering z1.  See what gets
written to $13, $14, and $6804 and what does the writing.
    - $13 and $14 get constantly written by z1 game code and by the transition_in initialization method.
    - $6804 (and sram in general) gets written only by z1 game code, and that sram is never touched by any quad code.

inventory.asm locations:
    007fed36 in rom file
    WriteItemToInventory: is at $e90b in snes sram (seed-patched-5.sfc)
    crashes on BRK #$C0 in .normalItem code (indexing into bad/misaligned data probably?)
    TODO: Debug how this operates under normal conditions in seed.sfc.
    






__Creating and distributing patches__

    ** Note: bps (bps-delta) patching produces erroneous results for what I need: applying target byte changes (and changes ONLY)
    to a crc-mismatched but length-equal seed (alpha or beta).  All other patch types tested (epb, rup, aps, ups, ppf, and ips) seem suitable.
    Let's use ebp since it works and is supported by the client library.

    Create bps patch with all branch changes:
    .\resources\flips.exe --create --exact --ignore-checksum --bps-delta .\build\baseline.sfc .\build\main.sfc .\build\quad-patch.bps

    Apply patch to a quad beta seed:
    .\resources\flips.exe --apply --ignore-checksum .\build\quad-patch.bps .\build\seed.sfc .\build\seed-patched.sfc

    Apply patch to a quad alpha seed:
    .\resources\flips.exe --apply --ignore-checksum .\build\quad-patch.bps .\build\seed-alpha.sfc .\build\seed-alpha-patched.sfc

    Fast cmd binary differences view (for verification):
    fc /b build\seed.sfc build\seed-patched.sfc

    Do a visual vim diff compare for the following:
        - main.sfc and seed.sfc (vanilla build vs. a beta seed)
        - seed.sfc and seed-alpha.sfc (beta vs. alpha)
    to get a sense of what blocks of data get loaded where, and how beta differs from alpha.

    Use https://www.marcrobledo.com/RomPatcher.js/ ,
    localStorage ,
    and ChatGPT to create a basic Svelte page which uses localStorage / filesystem api
    to store/open a seed rom on the user's pc.  The page action will then use 
    the client-side rom patcher library to apply the andy-testing bps patch to the seed rom,
    and then prompt the user to save the patched rom.
    Save the patched rom with filename:
        QUAD-v0.1.11b (#841c625)-1761507134[-andypropatch-2bea].sfc
        New part in [].
        This way, the full quad semver, commit id, seed id, my patch commit id, and the fact that
        it's been patched with this method is all contained in the filename.

    Copy/duplicate the quad site css for the most part
    It uses Bootstrap 4.6.2 yuck; maybe just duplicate the general look by hand with modern css

    For now, place a single precomputed bps patch in the project to be uploaded
    with the project assets to Netlify.

    Later:
    See what the best way automate putting particular bps patches named with last 4 chars of commit id
    into the web location.
    Seems like there could be a premade github action which does this or something netlify-specific.
    How would the svelte page know what files are available in the web dir?
