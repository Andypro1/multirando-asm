__ROM and CPU address layout discovery__

    001f8000 in main_z1.sfc is start
    002bf130 in main_z1.sfc is EOF
    00208000 in main_z1.sfc is start of bank 0:

    org $A08000
    incbin "../../resources/zelda1prg0.nes":($0010)-($4010)
    incbin "../../resources/zelda1prg0.nes":($1C010)-($20010)


    00600000 in main.sfc is start of bank 0 (but rom.asm says it should be 608000?)
    00608000 in main.sfc is start of bank 1
    00610000 in main.sfc is start of bank 2
    00618000 in main.sfc is start of bank 3
    00620000 in main.sfc is start of bank 4
    ...
    0063c000 in main.sfc is start of (final copy) bank 7

    007fffff in main.sfc is EOF

    ** Zelda 1 starts at 00600000 in rom
        length 4576e-976e == 3c000
    ** Metroid 1 starts at 00680004 in rom
        length == 38000
    Note that we can use asar's "print bytes" to determine ranges accurately, but NOT final offsets
    e.g., it correctly calculated the metroid rom taking 0x38000 bytes in main.sfc, but says its start offset is
    0x4effc (actual rom offset: 0x680004; not even close)

    Metroid 1 org vs. rom offset: $288000
    So bank 0 should start at $680000 rom / $908000 org
    Metroid 1 supplementary snes code vs. rom offset: $2c0000
    snes.asm should end at    $6b9c06 rom / $979c06 org



ring/tunic subroutine (no - this is something related to ganon/ganon triforce):
[0x8E, 0x02, 0x06, 0x8E, 0x72, 0x06, 0xEE, 0x4F, 0x03, 0x60]
STX $0602   ;  Duplicating the overwritten code (writing #$02)
STX $0672   ;  Copying [X (#$02)] to $0672 also (tunic palette maybe? rammap dunnos)
INC $034f   ;  Enemies killed on current screen (...)
RTS

8e 02 06 8e 72 06 ee 4f 03 60  - z1r has same [ganon-related] sub as above.  hmm.

20 e4 ff  z1r hook in exact same spot too..
The code does not seem to have anything to do with palettes or tunics or anything.
** Code runs on Ganon kill.  Makes more sense - it must be some type of ganon bugfix patch.

Create a patch from a vanilla rom change and apply it to a changed rom (different rando seed; whatever)
D:\Projects\multirando-asm\resources>flips --ignore-checksum --apply ..\build\Z-slowtext.bps ..\build\z1r.nes z1r-slowtext.nes
Done.  Works!


***  Bank_1_Code starts in SAVE RAM AT 006C90!!, not at 0x8000 where the rest of the swapped banks start
test offsets.

__Bank 1 low prg bank location example__
@Take: code starts with 20 xx xx B5(or BD) xx oo 29 3f 48
Located at 890f in cpu space
Located at 490f in the full rom (sans header)

__Bank 1 in save ram example__
TakeItem: code starts with:  a2 08 8e 02 06 c9 0e
Located at ABE0 in "bank 1 8000 offset",
which is   6bf0 in the full rom
which is   6be0 without the header
so subtract 4000 from the offsets in https://www.computerarcheology.com/NES/Zelda/Bank1.html

find this code in the mesen debugger
TakeItem: is at CPU 7370.  (1370 of sram)  
BANK1_CODE starts in rom (sans offset) at 6500.
BANK1_Code starts in sram at 0c90
So, CPU offsets into bank1 are <desired ROM location> + 0790.


Finding World_FillHearts sub:
    prg 628000 for bank 05.
    Bank 05 offset $3126(ish).  Find bytes below:
                   $B1E6:
171E6  A5 63          LDA $63                  ; else add 6.
171E8  F0 29          BEQ $B213
171EA  A9 10          LDA #$10
171EC  8D 04 06       STA $0604
171EF  AD 70 06       LDA $0670
171F2  C9 F8          CMP #$F8
171F4  B0 07          BCS $B1FD
171F6  18             CLC
                   ; They're equal, so make HeartPartial full by
171F7  69 06          ADC #$06
171F9  8D 70 06       STA $0670
171FC  60             RTS



sram 1484 is HandleClass2:
The ring portion at the end of this sub just stores the new palette byte
in 6804 (sram).  Then, stores #$18 (hardcode; not contingent on ring type)
in zero page $14 (TileBufSelector / ppu loading index)
and increments zero page $13 (game submode / routine index)

The motherbrain item obtain code references SRAM_ITEM_BUFFER
which unfortunately only stores the small snapshot of z1 ram that tracks items.
neither zero page nor wram at 6000 is stored in this shared sram space.
So: use the debugger and set a write breakpoint in wram at 6804, then trigger
a z1 transition to see if you can identify what code actually writes/restores
wram for z1.  Then do the same for a zero page value.
    - If this storage can be written by the motherbrain item obtain code, prefer that.
    - If not, find some other way
    - If in the unfathomable event that zero page and wram for z1 gets recreated from scratch
    on each and every game transition and values never get stored, you'll have to hack in the
    ring code somewhere during the transition / initialization (see transition_in.asm).
    There is specific manhandling of various zero page values in there, e.g.:
        stz $13     ; Clear submode

Try debug catching obtaining blue ring from shop, leaving z1, and reentering z1.  See what gets
written to $13, $14, and $6804 and what does the writing.
    - $13 and $14 get constantly written by z1 game code and by the transition_in initialization method.
    - $6804 (and sram in general) gets written only by z1 game code, and that sram is never touched by any quad code.

inventory.asm locations:
    007fed36 in rom file
    WriteItemToInventory: is at $e90b in snes sram (seed-patched-5.sfc)
        DONE:  Check on changes to WriteItemToInventory by collecting a z1 item in kak in an actual seed;
        then manipulate mem and register values to simulate z1 heart container overflow in the breakpoint
    

m1 up+A palette glitch:
    $67 and $68 control the currently loaded/loading tile palettes.  $00 $00 in these ram locations would
    cause the black and white palette.  But freezing the values doesn't fix the issue.
    
    Debug memory locations:
        prg 69488b [hooks.asm]
        prg 684b23 [hook location]
        prg 684158 [hook location]
        prg 6b98ed [UploadStartTilemap]
        prg 6B96EA [PrepareAttributesDMA]: Converts to snes format and loads tile attributes to ram @ 3000
            ->  Norfair Up+A snes ppu string sequence built by the above method:
                - a tilemap with 9 bytes of data at vram(?) 214b
                - DMA data with xxxxxxxxxxxxxxx at VMAIN (0080)
                ? what game process does hook at c30c attempt to capture?  It must be some type of
                "nes ppu string buffer transfer is complete," but perhaps there are other things that
                trigger this and need to be hooked as well.
            .TileAttr part of sub is at prg 6B940F (breakpoint)  - this does not appear to get run in normal game operation.

        memviewers:  wram 7a0 (nes ppu string buffer);  cpu 7e3000 (snes ppu string buffer)


        * After up+A, start in Norfair, the NES ppu string data at 7a0-7ff gets populated with the "ff" bytes
        representing the tile palette attributes for the first screen in Norfair.  The PrepareAttributesDMA never
        picks this up and runs the snes conversion.  Find out why not.


    * Found likely problem at sub UploadStartTilemap [snes.asm:1025].
    Total left a todo comment: ; TODO: Properly copy attribute data here as well
    $0c in VMDATAH for each tilemap entry produces the correct palette index of 03.
    Let's check what the actual game code does here.  NES doesn't add palette data per tile since it's handled per room.
    So I guess let's just read the Palette number for room from wram $68, shift it into position, and keep it
    in either a free register or a temp memory location.  Then palette info will be added to each tilemap entry loaded.


https://github.com/nmikstas/metroid-disassembly/blob/4270d57f9468daebdeea485686e31e26218a780c/Source_Files/Bank07.asm#L306
nes m1 $c195 writes to ppuio during ClearNameTable, and that causes the palette index to change, tile by tile, from 0 to 3.
Check what this code does in quad.


z1 give self good gear:
paste the following in memory viewer at $0650:
22 FF 00 00 00 00 01 03 FF 02 01 02 01 01 02 00
01 00 02 01 01 01 01 FF FF 01


z1 total door sprite hack uses tile 25 and palette 4 instead of tile 24 and palette 0, which is what the rest of the black
bar at the bottom of the hud uses.  Should be pretty easy to find/replace in that code.
    Tilemap addresses of the two blocks: $20ef and $20f0.
    - On transition_in to z1, add a sub that stuffs a black palette into palette index $71 (which is unused by the game).
    Then modify the door sprite hack to use palette index 7 for tile 25.
        palette cgram offset $0e2 and $0e3 for palette entry $71.


z1 flicker/palette bug looks to be the location of the vram window jumping around.
    Jumps/flickers at start of S->N transitions
    Jumps/flickers at end   of N->S transitions
    Pause menu transition is smooth and must be handled separately
    E->W and W->E transitions are also smooth and I don't see any flicker in the window movement (at least in tilemap viewer)

    - SnesProcessPPUString is called with type==0004 (DMA Data) which sends over $0180 length of palette data.
        It uses DMA to copy the palette bytes to vram from $4800 to $4b00 ($300 / 2 = $180).  This populates the
        correct palette data for roughly half of the bottom screen in vram (the one not currently being shown).
        * Find out why a second call is not issued to SnesProcessPPUString to populate palette data for the rest of
        the bottom screen.  ** Plot twist!:  It IS being issued AND processed, but the bottom half of VRAM is
        not being updated by the DMA execute call.  Diagnose.

        * Other glitchy graphics are corrupted OAM sprite data written (successfully) via DMA for one(?) frame.
        Trick here will be to see why the incorrect sprite data is being written to main memory @ $7e2000 to be copied.
        **  Other interesting fact is that BOTH the missing palette data AND the corrupt OAM data both occur together or not at all.
        This is looking more and more like a single bug.
        ***  During corrupt frames, the dma transfers for oam and bg attributes are occuring beyond the end of vblank and into
        scanlines in the next frame, and thus do not successfully write to vram (or something else for oam, partial write? idk).
        **** Find a breakpoint at common.asm/NMIStart and common.asm/NMIEnd, and piece together a complete picture of
        why SnesProcessPPUString ends up running outside of the NMI/vblank window.

    - Order of operations for snes z1 room transition:
        - prev frame during scanlines:  SnesOamPrepare [$0300 - $034f]
        - NMI (vblank):
            jsl SnesOamDMA
            jsl SnesProcessPPUString
            jsl nes_overlay_handle
            jsl SnesApplyBGPriority
        - z1 code hooks ((!BASE_BANK+$6)<<16)+$A08C --> SnesTransferTileBuf
            --> SnesPPUPrepare
            --> Chain of methods which handles the ppu data at $300 -> $34f (ending with PrepareAttributes and PrepareAttributesDMA, if applicable)
            - This means this process chain is running whenever it's triggered from z1 rom code,
            which for the attribute data happens to be a scanline or two before the end of NMI and thus
            bleeds into the next frame and the attribute data is delayed from transfer to the snes ppu by a frame (best guess).
            But, how come this doesn't run immediately at the top of the next frame?  it's still too delayed to explain.
            Sometimes the NES code sub CopyPlayAreaAttrsHalfToDynTransferBuf (which is supposed to all be in NMI???) is writing
            to $300 memory mid-frame, but then SnesPPUPrepare doesn't get its hands on that new data until
            near the end of the following NMI (and part even bleeds over to the next frame).  The late run
            here is compounded by the fact that previously prepared attribute data has to be read/DMAed before
            the new batch can be prepared........
            Check maybe hooking PreparePPUProcess in z1 right after the attribute $300 ram write.
                - hook RTS at end of CopyPlayAreaAttrsHalfToDynTransferBuf in bank 05
        *  Two of the three bugs causing this are now fixed in UpdateVScrollHDMA.
           the remaining bug is due to SnesProcessFrame running during NMI (which doesn't happen in m1!!), consuming over
           half of vblank and causing some dma writes to fail.  This causes both glitched sprite flicker
           as well as broken tile attributes.  Try to hook z1's "wait for NMI" just like has already been done for m1.

z1 hold item half sprite / no sprite bug:
    - Start by investigating / breaking on these hooks:
        org $81AC5B
            jsl TakeItem_SetItemValueFF_extended  (not interesting)
        org $81B19C
        jsl Anim_WriteSpecificItemSprites_extended
            - After returning to z1 game code, Anim_WriteSpritePair loads the left and right sprites from $0343 and $0344
            - prg 626817 is DrawLinkLiftingItem.
            - first glance it seems like we're not hooking enough of the Anim_ routines because the item sprite
            indexes are probably not being written to the right spots in ram.  Also we aren't writing the "wide sprite" byte
            so it's running the incorrect "narrow item" code.
    - Let's hook into / rewrite DrawLinkLiftingItem in bank 07.
        need to determine:
            - object index
            - item slot
            - item id: found in $0505 (-$30) during DrawLinkLiftingItem.
            - when dynamic item sprite gets unloaded from oam table (this happens earlier)
                - is triggered by processing nes oam data at $0300.  but what actually
                purges this dynamic sprite?
                - "dynamic" item 6e doesn't get purged even after finishing the collection and leaving the cave
                    ; Dynamic items
                    DynamicItemIndexes = $0A60

                    ; VRAM related
                    DynamicItemSlots = $0A68
                    DynamicItemAttrs = $0A70

                    ; Index to the current next slot to be loaded
                    DynamicItemIndex = $0A80

                    ; Returns the index into DynamicItemSlots for the item id provided
                    DynamicItemSlot = $0A82
        need to write 04 and 05 (left and right sprite "attributes")
        write 00 to 0c (anim frame 0)
        write 48  to $0343 (left sprite offset)
        write 4C  to $0344 (right sprite offset)
        then jsr to our Anim_WriteSpecificItemSprites_extended
        half of z3 heart sprite:  78 89 30 2D 78 91 32 2D
                                  78 89 30 2D 78 91 32 2D  in oam line 0d0

        - nes oam buffer @ 0300:
            - with heart container:
            3F 00 FF B6 08 24 24 24 24 24 24 24 24 20 D6 08
            F2 F2 F2 F2 F2 24 24 24 20 6C 03 21 02 01 20 AC
            03 21 0A 24 20 CC 03 02 05 04 FF 00
            - after heart container:
            3F 00 FF B6 08 24 24 24 24 24 24 24 24 20 D6 08
            F2 F2 F2 F2 F2 24 24 24 20 6C 03 21 02 01 20 AC
            03 21 0A 24 20 CC 03 02 05 04 FF 00

        DrawObjectWithAnim seems like starting point for determining how
        to draw onscreen objects
        HideObjectSprites: hides all sprites above index $18??  could be very relevant
        to what's happening  [no, that's like all the sprites.  something else is responsible
        for queueing the sprites required for the next frame..]

            blank sprites loaded as 7C 89 4E 21 7C 91 4F 21
            in oam.  Also found in memory at 7e2148
            previous was heart container tile.  Break on tile index write at 7e214a?
            SnesOamPrepare IS processing the dynamic external sprites.

        - Loaded sprites in the OAMNES struct starting at $0200 have tile indexes in the second position.
        E.g., a z1 heart container uses tile index $68 and $69.  But only $68 appears in the struct
        presumably because the sprite right after it is $69 and there's probably some attribute bit
        that it's a wide sprite so the full word should be loaded.
        The mirrored versions are stored further down (probably for easy bit math) and are also stored
        in the $68, $69 order.
            - Tracing backwards from OAMNES writes:
                - Anim_WriteMirroredSpritePair called when the sprite's tile index is in memory $02.
                - Anim_WriteSpecificItemSprites fallen into (with hooked code interspersed)
                - Anim_WriteStaticItemSpritesWithAttributes called
                - Anim_SetSpriteDescriptorAttributes called
                - DrawItemBySlot (hooked loads all around)
                * AnimateItemObject   this is called with [a]==ff for our item.
                    When switched to 6e, the code seems to mostly work (NO, this is just the shop floor item which is supposed to disappear)
                    LDA $0422,X has the shop warez.  when the ff here is switched to 6e, 
                    the heart STAYS ON THE SCREEN while link is holding it up although
                    the y coordinate is wrong and it stays on the flo.
                    I guess @Take is supposed to write $ff to the middle item slot when it's picked up.
                    that leaves us without a clue where the lift-over-head item is coming from (it's coming from $0505)

                - DrawLinkLiftingItem
                **** Anim_WriteSpritePairNotFlashing  - this is supposed to write the item from DrawLinkLiftingItem,
                    but trace through it carefully and see where $6e disappears from the registers/stack.
                    - It doesn't.  item $6e remains "loaded" in $0505 and correctly populates $00 - $0a with
                    its sprite halves information until the end of the lift animation.
                    The problem is the dynamic sprites cease to be OAMed on the frame when the object is collected.
                    STILL DON'T KNOW WHAT SETS/PREVENTS THIS

            mem $00 line entering room with e-tank:
                [pos: 80 90] [tileindexes: 30 32] [attrs: 05 05] 57 [2-sided: 01] FF 06 [x-sep: 08] 01 00 00 00 00
            mem $00 line entering uw cave with z3 heart container:
                [pos: 78 98] [tileindexes: 34 36] [attrs: 06 06] 10 [2-sided: 01] 01 06 [x-sep: 08] 0D 00 00 6D 00

                **  See when a native z1 heart container gets added to oam data during lifting.


            - z1/randomizer/newitems.asm:  The item attributes word seems to be symmetrical because
            the bytes are just game attribute bytes which are always the same for both halves of the item.
            - [$0505] DOES hold the correct item id ($1a for z1 heart container, e.g.)
            - Check the LoadItemId hooks in z1/randomizer/hooks.asm to see if those are more useful


__Creating and distributing patches__

    ** Note: bps (bps-delta) patching produces erroneous results for what I need: applying target byte changes (and changes ONLY)
    to a crc-mismatched but length-equal seed (alpha or beta).  All other patch types tested (epb, rup, aps, ups, ppf, and ips) seem suitable.
    Let's use ebp since it works and is supported by the client library.

    Create bps patch with all branch changes:
    .\resources\flips.exe --create --exact --ignore-checksum --bps-delta .\build\baseline.sfc .\build\main.sfc .\build\quad-patch.bps

    Apply patch to a quad beta seed:
    .\resources\flips.exe --apply --ignore-checksum .\build\quad-patch.bps .\build\seed.sfc .\build\seed-patched.sfc

    Apply patch to a quad alpha seed:
    .\resources\flips.exe --apply --ignore-checksum .\build\quad-patch.bps .\build\seed-alpha.sfc .\build\seed-alpha-patched.sfc

    Fast cmd binary differences view (for verification):
    fc /b build\seed.sfc build\seed-patched.sfc

    Do a visual vim diff compare for the following:
        - main.sfc and seed.sfc (vanilla build vs. a beta seed)
        - seed.sfc and seed-alpha.sfc (beta vs. alpha)
    to get a sense of what blocks of data get loaded where, and how beta differs from alpha.

    Use https://www.marcrobledo.com/RomPatcher.js/ ,
    localStorage ,
    and ChatGPT to create a basic Svelte page which uses localStorage / filesystem api
    to store/open a seed rom on the user's pc.  The page action will then use 
    the client-side rom patcher library to apply the andy-testing bps patch to the seed rom,
    and then prompt the user to save the patched rom.
    Save the patched rom with filename:
        QUAD-v0.1.11b (#841c625)-1761507134[-andypropatch-2bea].sfc
        New part in [].
        This way, the full quad semver, commit id, seed id, my patch commit id, and the fact that
        it's been patched with this method is all contained in the filename.

    Copy/duplicate the quad site css for the most part
    It uses Bootstrap 4.6.2 yuck; maybe just duplicate the general look by hand with modern css

    For now, place a single precomputed bps patch in the project to be uploaded
    with the project assets to Netlify.

    Later:
    See what the best way automate putting particular bps patches named with last 4 chars of commit id
    into the web location.
    Seems like there could be a premade github action which does this or something netlify-specific.
    How would the svelte page know what files are available in the web dir?
